// https://leetcode.com/problems/minimize-malware-spread/

template <typename T>
class disjoinSet {
    
    public :
    
    unordered_map<T, T> parentMap;
    unordered_map<T, int> rankMap;
    
    void createSet(T u) {
        parentMap[u] = u;
        rankMap[u] = 1;
    }
    
    T findSet(T u) {
        // base case
        if(parentMap[u] == u) {
            return u;
        }
        
        // recursive case
        return parentMap[u]=findSet(parentMap[u]);
    }
    
    void unionSet(T u, T v) {
        
        T l_u = findSet(u);
        T l_v = findSet(v);
        
        if(l_u != l_v) {
            if(rankMap[l_u] > rankMap[l_v]) {
                // make l_u the leader of l_v
                parentMap[l_v] = l_u;
                rankMap[l_u] += rankMap[l_v];
            } else {
                // make l_v the leader of l_u
                parentMap[l_u] = l_v;
                rankMap[l_v] += rankMap[l_u];
            }
        }
        
    }
    
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        disjoinSet<int> ds;
        
        int n = graph.size();
        for(int i=0; i<n; i++) {
            ds.createSet(i);
        }
        
        for(int i=0; i<n; i++) {
            for(int j=i+1; j<n; j++) {
                if(graph[i][j] == 1) {
                    // ith node is connected with the jth node
                    ds.unionSet(i, j);
                }
            }
        }
        
        vector<int> count(n); // to track no. of malwares in each component represented by the 'leader'
        
        for(int malware : initial) {
            int leader = ds.findSet(malware);
            count[leader]++;
        }
        
        
        int maxSize = 0;
        int bestMalware = INT_MAX; // to track the malware which infects the largest number of nodes in the graph and is unique in its component and therefore must be eliminated to minimize the spread
        
        for(int malware : initial) {
            int leader = ds.findSet(malware);
            if(count[leader] == 1) {
                // the component represented by 'leader' contains a single malware
                int size = ds.rankMap[leader]; // represents the no. of nodes in the component in which 'malware' is present
                if(size > maxSize) {
                    // eliminating 'malware' will create the maximum impact in eliminating the spread
                    bestMalware = malware; 
                    maxSize = size;
                } else if(size == maxSize) {
                    bestMalware = min(malware, bestMalware);
                }
            }
        }
        
        return bestMalware == INT_MAX ? *min_element(initial.begin(), initial.end()) : bestMalware;
        
    }
};